'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var path = require('path');
var types = require('@keystone-next/keystone/types');
var keystone = require('@keystone-next/keystone');
var cuid = require('cuid');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var cloudinary = require('cloudinary');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var cuid__default = /*#__PURE__*/_interopDefault(cuid);
var cloudinary__default = /*#__PURE__*/_interopDefault(cloudinary);

const _excluded$1 = ["prettyName"];

function uploadStream(stream, options) {
  return new Promise((resolve, reject) => {
    const cloudinaryStream = cloudinary__default["default"].v2.uploader.upload_stream(options, (error, result) => {
      if (error || !result) {
        return reject(error);
      }

      resolve(result);
    });
    stream.pipe(cloudinaryStream);
  });
}

class CloudinaryAdapter {
  constructor({
    cloudName,
    apiKey,
    apiSecret,
    folder
  }) {
    _defineProperty(this, "cloudName", void 0);

    _defineProperty(this, "apiKey", void 0);

    _defineProperty(this, "apiSecret", void 0);

    _defineProperty(this, "folder", void 0);

    if (!cloudName || !apiKey || !apiSecret) {
      throw new Error('CloudinaryAdapter requires cloudName, apiKey, and apiSecret');
    }

    this.cloudName = cloudName;
    this.apiKey = apiKey;
    this.apiSecret = apiSecret;
    this.folder = folder || undefined;
  }
  /**
   * Params: { stream, filename, id }
   */


  save({
    stream,
    filename,
    id
  }) {
    // Push to cloudinary
    return uploadStream(stream, {
      public_id: id,
      folder: this.folder,
      // Auth
      api_key: this.apiKey,
      api_secret: this.apiSecret,
      cloud_name: this.cloudName
    }).then(result => ({
      // Return the relevant data for the File api
      id,
      filename,
      _meta: result
    }));
  }
  /**
   * Deletes the given file from cloudinary
   * @param file File field data
   * @param options Delete options passed to cloudinary.
   *                For available options refer to the [Cloudinary destroy API](https://cloudinary.com/documentation/image_upload_api_reference#destroy_method).
   */


  delete(file, options = {}) {
    const destroyOptions = _objectSpread({
      // Auth
      api_key: this.apiKey,
      api_secret: this.apiSecret,
      cloud_name: this.cloudName
    }, options);

    return new Promise((resolve, reject) => {
      if (file) {
        // @ts-ignore
        cloudinary__default["default"].v2.uploader.destroy(file._meta.public_id, destroyOptions, (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        });
      } else {
        reject(new Error("Missing required argument 'file'."));
      }
    });
  }

  publicUrl(file) {
    var _file$_meta;

    return (file === null || file === void 0 ? void 0 : (_file$_meta = file._meta) === null || _file$_meta === void 0 ? void 0 : _file$_meta.secure_url) || null;
  }

  publicUrlTransformed(file, options = {}) {
    if (!file._meta) {
      return null;
    }

    const {
      prettyName
    } = options,
          transformation = _objectWithoutProperties(options, _excluded$1); // No formatting options provided, return the publicUrl field


    if (!Object.keys(transformation).length) {
      return this.publicUrl(file);
    }

    const {
      public_id,
      format
    } = file._meta; // Docs: https://github.com/cloudinary/cloudinary_npm/blob/439586eac73cee7f2803cf19f885e98f237183b3/src/utils.coffee#L472 (LOL)
    // @ts-ignore

    return cloudinary__default["default"].url(public_id, {
      type: 'upload',
      format,
      secure: true,
      url_suffix: prettyName,
      transformation,
      cloud_name: this.cloudName
    });
  }

}

const _excluded = ["cloudinary"];
const CloudinaryImageFormat = keystone.graphql.inputObject({
  name: 'CloudinaryImageFormat',
  description: 'Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).\n' + 'All options are strings as they ultimately end up in a URL.',
  fields: {
    prettyName: keystone.graphql.arg({
      description: ' Rewrites the filename to be this pretty string. Do not include `/` or `.`',
      type: keystone.graphql.String
    }),
    width: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    height: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    crop: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    aspect_ratio: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    gravity: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    zoom: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    x: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    y: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    format: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    fetch_format: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    quality: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    radius: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    angle: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    effect: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    opacity: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    border: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    background: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    overlay: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    underlay: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    default_image: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    delay: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    color: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    color_space: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    dpr: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    page: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    density: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    flags: keystone.graphql.arg({
      type: keystone.graphql.String
    }),
    transformation: keystone.graphql.arg({
      type: keystone.graphql.String
    })
  }
});
const outputType = keystone.graphql.object()({
  name: 'CloudinaryImage_File',
  fields: {
    id: keystone.graphql.field({
      type: keystone.graphql.ID
    }),
    // path: types.field({ type: types.String }),
    filename: keystone.graphql.field({
      type: keystone.graphql.String
    }),
    originalFilename: keystone.graphql.field({
      type: keystone.graphql.String
    }),
    mimetype: keystone.graphql.field({
      type: keystone.graphql.String
    }),
    encoding: keystone.graphql.field({
      type: keystone.graphql.String
    }),
    publicUrl: keystone.graphql.field({
      type: keystone.graphql.String
    }),
    publicUrlTransformed: keystone.graphql.field({
      args: {
        transformation: keystone.graphql.arg({
          type: CloudinaryImageFormat
        })
      },
      type: keystone.graphql.String,

      resolve(rootVal, args) {
        return rootVal.publicUrlTransformed(args);
      }

    })
  }
});
const cloudinaryImage = _ref => {
  let {
    cloudinary
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded);

  return meta => {
    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type cloudinaryImage");
    }

    const adapter = new CloudinaryAdapter(cloudinary);

    const resolveInput = async uploadData => {
      if (uploadData === null) {
        return meta.provider === 'postgresql' ? 'DbNull' : null;
      }

      if (uploadData === undefined) {
        return undefined;
      }

      const {
        createReadStream,
        filename: originalFilename,
        mimetype,
        encoding
      } = await uploadData;
      const stream = createReadStream();

      if (!stream) {
        // TODO: FIXME: Handle when stream is null. Can happen when:
        // Updating some other part of the item, but not the file (gets null
        // because no File DOM element is uploaded)
        return undefined;
      }

      const {
        id,
        filename,
        _meta
      } = await adapter.save({
        stream,
        filename: originalFilename,
        id: cuid__default["default"]()
      });
      return {
        id,
        filename,
        originalFilename,
        mimetype,
        encoding,
        _meta
      };
    };

    return types.jsonFieldTypePolyfilledForSQLite(meta.provider, _objectSpread(_objectSpread({}, config), {}, {
      input: {
        create: {
          arg: keystone.graphql.arg({
            type: keystone.graphql.Upload
          }),
          resolve: resolveInput
        },
        update: {
          arg: keystone.graphql.arg({
            type: keystone.graphql.Upload
          }),
          resolve: resolveInput
        }
      },
      output: keystone.graphql.field({
        type: outputType,

        resolve({
          value
        }) {
          if (value === null) {
            return null;
          }

          const val = value;
          return _objectSpread({
            publicUrl: adapter.publicUrl(val),
            publicUrlTransformed: ({
              transformation
            }) => adapter.publicUrlTransformed(val, transformation !== null && transformation !== void 0 ? transformation : {})
          }, val);
        }

      }),
      views: path__default["default"].join(path__default["default"].dirname(__dirname), 'views')
    }));
  };
};

exports.cloudinaryImage = cloudinaryImage;
