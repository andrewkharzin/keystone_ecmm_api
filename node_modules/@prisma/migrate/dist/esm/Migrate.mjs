var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import { parseEnvValue } from "@prisma/sdk";
import { getSchemaPathSync, getGenerators } from "@prisma/sdk";
import chalk from "chalk";
import Debug from "@prisma/debug";
import fs from "fs";
import logUpdate from "log-update";
import path from "path";
import { MigrateEngine } from "./MigrateEngine";
import { formatms } from "./utils/formatms";
import { enginesVersion } from "@prisma/engines-version";
import { NoSchemaFoundError } from "./utils/errors";
const debug = Debug("prisma:migrate");
const packageJson = eval(`require('../package.json')`);
class Migrate {
  get devMigrationsDir() {
    return path.join(path.dirname(this.schemaPath), "migrations/dev");
  }
  constructor(schemaPath, enabledPreviewFeatures) {
    this.schemaPath = this.getSchemaPath(schemaPath);
    this.migrationsDirectoryPath = path.join(path.dirname(this.schemaPath), "migrations");
    this.engine = new MigrateEngine({
      projectDir: path.dirname(this.schemaPath),
      schemaPath: this.schemaPath,
      enabledPreviewFeatures
    });
  }
  stop() {
    this.engine.stop();
  }
  getSchemaPath(schemaPathFromOptions) {
    const schemaPath = getSchemaPathSync(schemaPathFromOptions);
    if (!schemaPath) {
      throw new NoSchemaFoundError();
    }
    return schemaPath;
  }
  getDatamodel() {
    return fs.readFileSync(this.schemaPath, "utf-8");
  }
  reset() {
    return this.engine.reset();
  }
  createMigration(params) {
    return this.engine.createMigration(params);
  }
  diagnoseMigrationHistory({
    optInToShadowDatabase
  }) {
    return this.engine.diagnoseMigrationHistory({
      migrationsDirectoryPath: this.migrationsDirectoryPath,
      optInToShadowDatabase
    });
  }
  listMigrationDirectories() {
    return this.engine.listMigrationDirectories({
      migrationsDirectoryPath: this.migrationsDirectoryPath
    });
  }
  devDiagnostic() {
    return this.engine.devDiagnostic({
      migrationsDirectoryPath: this.migrationsDirectoryPath
    });
  }
  async markMigrationApplied({ migrationId }) {
    return await this.engine.markMigrationApplied({
      migrationsDirectoryPath: this.migrationsDirectoryPath,
      migrationName: migrationId
    });
  }
  markMigrationRolledBack({ migrationId }) {
    return this.engine.markMigrationRolledBack({
      migrationName: migrationId
    });
  }
  applyMigrations() {
    return this.engine.applyMigrations({
      migrationsDirectoryPath: this.migrationsDirectoryPath
    });
  }
  evaluateDataLoss() {
    const datamodel = this.getDatamodel();
    return this.engine.evaluateDataLoss({
      migrationsDirectoryPath: this.migrationsDirectoryPath,
      prismaSchema: datamodel
    });
  }
  async push({ force = false }) {
    const datamodel = this.getDatamodel();
    const { warnings, unexecutable, executedSteps } = await this.engine.schemaPush({
      force,
      schema: datamodel
    });
    return {
      executedSteps,
      warnings,
      unexecutable
    };
  }
  async tryToRunGenerate() {
    const message = [];
    console.info();
    logUpdate(`Running generate... ${chalk.dim("(Use --skip-generate to skip the generators)")}`);
    const generators = await getGenerators({
      schemaPath: this.schemaPath,
      printDownloadProgress: true,
      version: enginesVersion,
      cliVersion: packageJson.version
    });
    for (const generator of generators) {
      const toStr = generator.options.generator.output ? chalk.dim(` to .${path.sep}${path.relative(process.cwd(), parseEnvValue(generator.options.generator.output))}`) : "";
      const name = generator.manifest ? generator.manifest.prettyName : parseEnvValue(generator.options.generator.provider);
      logUpdate(`Running generate... - ${name}`);
      const before = Date.now();
      try {
        await generator.generate();
        const after = Date.now();
        const version = generator.manifest?.version;
        message.push(`\u2714 Generated ${chalk.bold(name)}${version ? ` (${version})` : ""}${toStr} in ${formatms(after - before)}`);
        generator.stop();
      } catch (e) {
        message.push(`${e.message}`);
        generator.stop();
      }
    }
    logUpdate(message.join("\n"));
  }
}
__name(Migrate, "Migrate");
export {
  Migrate
};
