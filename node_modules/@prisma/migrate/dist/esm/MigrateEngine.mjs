var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import Debug from "@prisma/debug";
import { BinaryType, ErrorArea, resolveBinary, RustPanic, MigrateEngineExitCode } from "@prisma/sdk";
import chalk from "chalk";
import { spawn } from "child_process";
import byline from "./utils/byline";
const debugRpc = Debug("prisma:migrateEngine:rpc");
const debugStderr = Debug("prisma:migrateEngine:stderr");
const debugStdin = Debug("prisma:migrateEngine:stdin");
class EngineError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
__name(EngineError, "EngineError");
let messageId = 1;
class MigrateEngine {
  constructor({ projectDir, debug = false, schemaPath, enabledPreviewFeatures }) {
    this.listeners = {};
    this.messages = [];
    this.lastError = null;
    this.projectDir = projectDir;
    this.schemaPath = schemaPath;
    if (debug) {
      Debug.enable("MigrateEngine*");
    }
    this.debug = debug;
    this.enabledPreviewFeatures = enabledPreviewFeatures;
  }
  stop() {
    this.child.kill();
  }
  devDiagnostic(args) {
    return this.runCommand(this.getRPCPayload("devDiagnostic", args));
  }
  listMigrationDirectories(args) {
    return this.runCommand(this.getRPCPayload("listMigrationDirectories", args));
  }
  markMigrationApplied(args) {
    return this.runCommand(this.getRPCPayload("markMigrationApplied", args));
  }
  markMigrationRolledBack(args) {
    return this.runCommand(this.getRPCPayload("markMigrationRolledBack", args));
  }
  diagnoseMigrationHistory(args) {
    return this.runCommand(this.getRPCPayload("diagnoseMigrationHistory", args));
  }
  planMigration(args) {
    return this.runCommand(this.getRPCPayload("planMigration", args));
  }
  evaluateDataLoss(args) {
    return this.runCommand(this.getRPCPayload("evaluateDataLoss", args));
  }
  createMigration(args) {
    return this.runCommand(this.getRPCPayload("createMigration", args));
  }
  applyMigrations(args) {
    return this.runCommand(this.getRPCPayload("applyMigrations", args));
  }
  reset() {
    return this.runCommand(this.getRPCPayload("reset", void 0));
  }
  getDatabaseVersion() {
    return this.runCommand(this.getRPCPayload("getDatabaseVersion", void 0));
  }
  schemaPush(args) {
    return this.runCommand(this.getRPCPayload("schemaPush", args));
  }
  debugPanic() {
    return this.runCommand(this.getRPCPayload("debugPanic", void 0));
  }
  rejectAll(err) {
    Object.entries(this.listeners).map(([id, listener]) => {
      listener(null, err);
      delete this.listeners[id];
    });
  }
  registerCallback(id, callback) {
    this.listeners[id] = callback;
  }
  handleResponse(response) {
    let result;
    try {
      result = JSON.parse(response);
    } catch (e) {
      console.error(`Could not parse migration engine response: ${response.slice(0, 200)}`);
    }
    if (result) {
      if (result.id) {
        if (!this.listeners[result.id]) {
          console.error(`Got result for unknown id ${result.id}`);
        }
        if (this.listeners[result.id]) {
          this.listeners[result.id](result);
          delete this.listeners[result.id];
        }
      } else {
        if (result.is_panic) {
          throw new Error(`Response: ${result.message}`);
        } else if (result.message) {
          console.error(chalk.red(`Response: ${result.message}`));
        } else {
          console.error(chalk.red(`Response: ${JSON.stringify(result)}`));
        }
      }
    }
  }
  init() {
    if (!this.initPromise) {
      this.initPromise = this.internalInit();
    }
    return this.initPromise;
  }
  internalInit() {
    return new Promise(async (resolve, reject) => {
      try {
        const { PWD, ...rest } = process.env;
        const binaryPath = await resolveBinary(BinaryType.migrationEngine);
        debugRpc("starting migration engine with binary: " + binaryPath);
        const args = ["-d", this.schemaPath];
        if (this.enabledPreviewFeatures && Array.isArray(this.enabledPreviewFeatures) && this.enabledPreviewFeatures.length > 0) {
          args.push(...["--enabled-preview-features", this.enabledPreviewFeatures.join(",")]);
        }
        this.child = spawn(binaryPath, args, {
          cwd: this.projectDir,
          stdio: ["pipe", "pipe", this.debug ? process.stderr : "pipe"],
          env: {
            ...rest,
            SERVER_ROOT: this.projectDir,
            RUST_LOG: "info",
            RUST_BACKTRACE: "1"
          }
        });
        this.child.on("error", (err) => {
          console.error("[migration-engine] error: %s", err);
          this.rejectAll(err);
          reject(err);
        });
        this.child.on("exit", (code) => {
          const exitWithErr = /* @__PURE__ */ __name((err) => {
            this.rejectAll(err);
            reject(err);
          }, "exitWithErr");
          const engineMessage = this.lastError?.message || this.messages.join("\n");
          const handlePanic = /* @__PURE__ */ __name(() => {
            const stackTrace = this.messages.join("\n");
            exitWithErr(new RustPanic(serializePanic(engineMessage), stackTrace, this.lastRequest, ErrorArea.LIFT_CLI, this.schemaPath));
          }, "handlePanic");
          switch (code) {
            case MigrateEngineExitCode.Success:
              break;
            case MigrateEngineExitCode.Error:
              exitWithErr(new Error(`Error in migration engine: ${engineMessage}`));
              break;
            case MigrateEngineExitCode.Panic:
              handlePanic();
              break;
            default:
              handlePanic();
          }
        });
        this.child.stdin.on("error", (err) => {
          debugStdin(err);
        });
        byline(this.child.stderr).on("data", (msg) => {
          const data = String(msg);
          debugStderr(data);
          try {
            const json = JSON.parse(data);
            if (json.fields?.migrate_action === "log") {
              console.info(json.fields.message);
            }
            this.messages.push(json.fields.message);
            if (json.level === "ERROR") {
              this.lastError = json.fields;
            }
          } catch (e) {
          }
        });
        byline(this.child.stdout).on("data", (line) => {
          this.handleResponse(String(line));
        });
        setImmediate(() => {
          resolve();
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  async runCommand(request) {
    if (process.env.FORCE_PANIC_MIGRATION_ENGINE) {
      request = this.getRPCPayload("debugPanic", void 0);
    }
    await this.init();
    if (this.child?.killed) {
      throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine already exited.`);
    }
    return new Promise((resolve, reject) => {
      this.registerCallback(request.id, (response, err) => {
        if (err) {
          return reject(err);
        }
        if (response.result !== void 0) {
          resolve(response.result);
        } else {
          if (response.error) {
            debugRpc(response);
            if (response.error.data?.is_panic) {
              const message = response.error.data?.error?.message ?? response.error.message;
              reject(new RustPanic(message, response.error.data.message, this.lastRequest, ErrorArea.LIFT_CLI, this.schemaPath));
            } else if (response.error.data?.message) {
              let message = `${chalk.redBright(response.error.data.message)}
`;
              if (response.error.data?.error_code) {
                message = chalk.redBright(`${response.error.data.error_code}

`) + message;
                reject(new EngineError(message, response.error.data.error_code));
              } else {
                reject(new Error(message));
              }
            } else {
              reject(new Error(`${chalk.redBright("Error in RPC")}
 Request: ${JSON.stringify(request, null, 2)}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`));
            }
          } else {
            reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
          }
        }
      });
      if (this.child.stdin.destroyed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine is destroyed.`);
      }
      debugRpc("SENDING RPC CALL", JSON.stringify(request));
      this.child.stdin.write(JSON.stringify(request) + "\n");
      this.lastRequest = request;
    });
  }
  getRPCPayload(method, params) {
    return {
      id: messageId++,
      jsonrpc: "2.0",
      method,
      params: {
        ...params
      }
    };
  }
}
__name(MigrateEngine, "MigrateEngine");
function serializePanic(log) {
  return `${chalk.red.bold("Error in migration engine.\nReason: ")}${log}

Please create an issue with your \`schema.prisma\` at
${chalk.underline("https://github.com/prisma/prisma/issues/new")}
`;
}
__name(serializePanic, "serializePanic");
export {
  EngineError,
  MigrateEngine
};
