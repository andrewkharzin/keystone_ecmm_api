var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import { getSchema, getSchemaDir } from "@prisma/sdk";
import { getConfig } from "@prisma/sdk";
import chalk from "chalk";
import { uriToCredentials, createDatabase, canConnectToDatabase } from "@prisma/sdk";
import prompt from "prompts";
async function getDbInfo(schemaPath) {
  const datamodel = await getSchema(schemaPath);
  const config = await getConfig({ datamodel });
  const activeDatasource = config.datasources[0];
  const url = activeDatasource.url.value;
  if (activeDatasource.provider === "sqlserver") {
    return {
      name: activeDatasource.name,
      schemaWord: "database",
      dbType: "SQL Server",
      dbName: void 0,
      dbLocation: void 0,
      url: activeDatasource.url.value
    };
  }
  try {
    const credentials = uriToCredentials(url);
    const dbLocation = getDbLocation(credentials);
    const dbinfoFromCredentials = getDbinfoFromCredentials(credentials);
    return {
      name: activeDatasource.name,
      dbLocation,
      ...dbinfoFromCredentials,
      url,
      schema: credentials.schema
    };
  } catch (e) {
    return {
      name: activeDatasource.name,
      schemaWord: "database",
      dbType: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url
    };
  }
}
__name(getDbInfo, "getDbInfo");
async function ensureCanConnectToDatabase(schemaPath) {
  const datamodel = await getSchema(schemaPath);
  const config = await getConfig({ datamodel });
  const activeDatasource = config.datasources[0];
  if (!activeDatasource) {
    throw new Error(`Couldn't find a datasource in the schema.prisma file`);
  }
  const schemaDir = await getSchemaDir(schemaPath);
  const canConnect = await canConnectToDatabase(activeDatasource.url.value, schemaDir);
  if (canConnect === true) {
    return true;
  } else {
    const { code, message } = canConnect;
    throw new Error(`${code}: ${message}`);
  }
}
__name(ensureCanConnectToDatabase, "ensureCanConnectToDatabase");
async function ensureDatabaseExists(action, forceCreate = false, schemaPath) {
  const datamodel = await getSchema(schemaPath);
  const config = await getConfig({ datamodel });
  const activeDatasource = config.datasources[0];
  if (!activeDatasource) {
    throw new Error(`Couldn't find a datasource in the schema.prisma file`);
  }
  const schemaDir = await getSchemaDir(schemaPath);
  const canConnect = await canConnectToDatabase(activeDatasource.url.value, schemaDir);
  if (canConnect === true) {
    return;
  }
  const { code, message } = canConnect;
  if (code !== "P1003") {
    throw new Error(`${code}: ${message}`);
  }
  if (!schemaDir) {
    throw new Error(`Could not locate ${schemaPath || "schema.prisma"}`);
  }
  if (forceCreate) {
    if (await createDatabase(activeDatasource.url.value, schemaDir)) {
      if (activeDatasource.provider === "sqlserver") {
        return `SQL Server database created.
`;
      }
      const credentials = uriToCredentials(activeDatasource.url.value);
      const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
      if (dbType && dbType !== "SQL Server") {
        return `${dbType} ${schemaWord} ${chalk.bold(dbName)} created at ${chalk.bold(getDbLocation(credentials))}`;
      } else {
        return `${schemaWord} created.`;
      }
    }
  } else {
    await interactivelyCreateDatabase(activeDatasource.url.value, action, schemaDir);
  }
  return void 0;
}
__name(ensureDatabaseExists, "ensureDatabaseExists");
async function interactivelyCreateDatabase(connectionString, action, schemaDir) {
  await askToCreateDb(connectionString, action, schemaDir);
}
__name(interactivelyCreateDatabase, "interactivelyCreateDatabase");
async function askToCreateDb(connectionString, action, schemaDir) {
  const credentials = uriToCredentials(connectionString);
  const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
  const dbLocation = getDbLocation(credentials);
  let message;
  if (dbName && dbLocation) {
    message = `You are trying to ${action} a migration for ${dbType} ${schemaWord} ${chalk.bold(dbName)}.
A ${schemaWord} with that name doesn't exist at ${chalk.bold(dbLocation)}.
`;
  } else {
    message = `You are trying to ${action} a migration for ${dbType} ${schemaWord}.
The ${schemaWord} doesn't exist.
`;
  }
  console.info();
  const response = await prompt({
    type: "select",
    name: "value",
    message,
    initial: 0,
    choices: [
      {
        title: "Yes",
        value: true,
        description: `Create new ${dbType} ${schemaWord} ${chalk.bold(dbName)}`
      },
      {
        title: "No",
        value: false,
        description: `Don't create the ${schemaWord}`
      }
    ]
  });
  if (response.value) {
    await createDatabase(connectionString, schemaDir);
  } else {
    process.exit(0);
  }
}
__name(askToCreateDb, "askToCreateDb");
function getDbLocation(credentials) {
  if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  if (!credentials.port) {
    switch (credentials.type) {
      case "mysql":
        credentials.port = 3306;
        break;
      case "postgresql":
        credentials.port = 5432;
        break;
      case "sqlserver":
        credentials.port = 1433;
        break;
    }
  }
  return `${credentials.host}:${credentials.port}`;
}
__name(getDbLocation, "getDbLocation");
function getDbinfoFromCredentials(credentials) {
  const dbName = credentials.database;
  let dbType;
  switch (credentials.type) {
    case "mysql":
      dbType = `MySQL`;
      break;
    case "postgresql":
      dbType = `PostgreSQL`;
      break;
    case "sqlite":
      dbType = `SQLite`;
      break;
    case "sqlserver":
      dbType = `SQL Server`;
      break;
  }
  const schemaWord = "database";
  return {
    dbName,
    dbType,
    schemaWord
  };
}
__name(getDbinfoFromCredentials, "getDbinfoFromCredentials");
export {
  askToCreateDb,
  ensureCanConnectToDatabase,
  ensureDatabaseExists,
  getDbInfo,
  getDbLocation,
  getDbinfoFromCredentials,
  interactivelyCreateDatabase
};
